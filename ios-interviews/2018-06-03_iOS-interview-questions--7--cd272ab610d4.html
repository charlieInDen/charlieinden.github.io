<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>iOS interview questions (7)</title>
    <style>
      * {
        font-family: Georgia, Cambria, 'Times New Roman', Times, serif;
      }
      html,
      body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field='subtitle'],
      section[data-field='description'] {
        display: none;
      }
    </style>
  </head>
  <body>
    <article class="h-entry">
      <header>
        <h1 class="p-name">iOS interview questions (7)</h1>
      </header>
      <section data-field="subtitle" class="p-summary">
        Core Data &amp; Concurrency
      </section>
      <section data-field="description" class="p-summary">
        Let&#39;s suppose , you&#39;re developing a small or simple application,
        then you probably don&#39;t see the benefit of running Core Data
        operations in the background. However, what would happen if you
        imported‚Ä¶
      </section>
      <section data-field="body" class="e-content">
        <section
          name="5fa3"
          class="section section--body section--first section--last"
        >
          <div class="section-divider"><hr class="section-divider" /></div>
          <div class="section-content">
            <div class="section-inner sectionLayout--insetColumn">
              <h3
                name="621b"
                id="621b"
                class="graf graf--h3 graf--leading graf--title"
              >
                iOS 2018 Series: Cracking iOS interview or Become iOS expert¬†(7)
              </h3>
              <p name="1622" id="1622" class="graf graf--p graf-after--h3">
                <strong class="markup--strong markup--p-strong"
                  >Chapter 7: Core Data &amp; Concurrency</strong
                >
              </p>
              <p name="b5de" id="b5de" class="graf graf--p graf-after--p">
                Let‚Äôs suppose¬†, you‚Äôre developing a small or simple application,
                then you probably don‚Äôt see the benefit of running Core Data
                operations in the background. However, what would happen if you
                imported hundreds or thousands of records on the main thread
                during the first launch of your application? The consequences
                could be dramatic. We have face all these kind of issue in real
                programming world when worked with core data so lets discuss the
                solution..
              </p>
              <h3 name="6eeb" id="6eeb" class="graf graf--h3 graf-after--p">
                Basics:
              </h3>
              <p name="a6c4" id="a6c4" class="graf graf--p graf-after--h3">
                Core Data is a framework that you use to manage the model layer
                objects in your application
              </p>
              <p name="4cee" id="4cee" class="graf graf--p graf-after--p">
                Concurrency is the ability to work with the data on more than
                one queue at the same time.
              </p>
              <figure
                name="9ba5"
                id="9ba5"
                class="graf graf--figure graf-after--p"
              >
                <img
                  class="graf-image"
                  data-image-id="1*2rauIkaE9DRtUGTizu84iw.png"
                  data-width="1100"
                  data-height="586"
                  src="https://cdn-images-1.medium.com/max/800/1*2rauIkaE9DRtUGTizu84iw.png"
                />
              </figure>
              <h3
                name="05da"
                id="05da"
                class="graf graf--h3 graf-after--figure"
              >
                Steps:
              </h3>
              <h4 name="53af" id="53af" class="graf graf--h4 graf-after--h3">
                <strong class="markup--strong markup--h4-strong"
                  ><em class="markup--em markup--h4-em"
                    >* Initializing the Core Data¬†Stack</em
                  ></strong
                >
              </h4>
              <ol class="postList">
                <li name="92cf" id="92cf" class="graf graf--li graf-after--h4">
                  Create Manage object model instance using model file
                </li>
                <li name="05c0" id="05c0" class="graf graf--li graf-after--li">
                  Create persistent store coordinator using Manage object model
                  instance
                </li>
                <li name="5802" id="5802" class="graf graf--li graf-after--li">
                  Add persistent store in PSC instance using SQLite or other
                  type and file path for SQLite dB
                </li>
                <li name="e087" id="e087" class="graf graf--li graf-after--li">
                  Create Managed Object Context with concurrency type‚Ää‚Äî
                  <code class="markup--code markup--li-code"
                    >NSMainQueueConcurrencyType</code
                  >
                  and
                  <code class="markup--code markup--li-code"
                    >NSPrivateQueueConcurrencyType</code
                  >.
                </li>
                <li name="2563" id="2563" class="graf graf--li graf-after--li">
                  Set persistent store coordinator in Manage object model
                  instance.
                </li>
              </ol>
              <h4 name="9bb7" id="9bb7" class="graf graf--h4 graf-after--li">
                <strong class="markup--strong markup--h4-strong"
                  ><em class="markup--em markup--h4-em"
                    >* Creating and Saving Managed¬†Objects</em
                  ></strong
                >
              </h4>
              <ol class="postList">
                <li name="a274" id="a274" class="graf graf--li graf-after--h4">
                  Create entity using NSEntityDescription entity
                </li>
                <li name="48ba" id="48ba" class="graf graf--li graf-after--li">
                  Create instance of row which need to be inserted which will be
                  Managed Object instance using entity and MOC.
                </li>
                <li name="055e" id="055e" class="graf graf--li graf-after--li">
                  set Value in MO instance
                </li>
                <li name="e692" id="e692" class="graf graf--li graf-after--li">
                  Save MO entry in core data‚Ää‚Äî‚Ääcontext. Save()
                </li>
              </ol>
              <h4 name="11f6" id="11f6" class="graf graf--h4 graf-after--li">
                <strong class="markup--strong markup--h4-strong"
                  >* Fetching¬†Objects</strong
                >
              </h4>
              <ol class="postList">
                <li name="cf42" id="cf42" class="graf graf--li graf-after--h4">
                  Prepare the request of type NSFetchRequest for the entity
                </li>
              </ol>
              <p name="cab6" id="cab6" class="graf graf--p graf-after--li">
                <strong class="markup--strong markup--p-strong"
                  >let request =
                  NSFetchRequest&lt;NSFetchRequestResult&gt;(entityName:
                  ‚ÄúUsers‚Äù)</strong
                >
              </p>
              <p name="f811" id="f811" class="graf graf--p graf-after--p">
                2. Fetch the result from context in the form of array of
                [NSManagedObject]
              </p>
              <p name="266c" id="266c" class="graf graf--p graf-after--p">
                <strong class="markup--strong markup--p-strong"
                  >let result = try context.fetch(request)</strong
                >
              </p>
              <p name="5ea4" id="5ea4" class="graf graf--p graf-after--p">
                3. Iterate through an array to get value for the specific key
              </p>
              <p name="7a13" id="7a13" class="graf graf--p graf-after--p">
                <strong class="markup--strong markup--p-strong"
                  >for data in result as! [NSManagedObject]</strong
                >
              </p>
              <h3 name="19d2" id="19d2" class="graf graf--h3 graf-after--p">
                Core Data Stack Setup‚Ää‚Äî‚ÄäThe Easy Way (NSPersistentContainer)
              </h3>
              <figure
                name="482e"
                id="482e"
                class="graf graf--figure graf-after--h3"
              >
                <img
                  class="graf-image"
                  data-image-id="1*RTBpioFnBiziE1FfXcCsdg.png"
                  data-width="625"
                  data-height="335"
                  data-is-featured="true"
                  src="https://cdn-images-1.medium.com/max/800/1*RTBpioFnBiziE1FfXcCsdg.png"
                />
              </figure>
              <p name="f47e" id="f47e" class="graf graf--p graf-after--figure">
                Setting up a Core Data stack takes some work. A typical setup
                needs a number of steps:
              </p>
              <ul class="postList">
                <li name="2e77" id="2e77" class="graf graf--li graf-after--p">
                  Load the
                  <strong class="markup--strong markup--li-strong"
                    >managed object model</strong
                  >
                  from the application bundle
                </li>
                <li name="1563" id="1563" class="graf graf--li graf-after--li">
                  Create a
                  <strong class="markup--strong markup--li-strong"
                    >persistent store coordinator</strong
                  >
                  with the model
                </li>
                <li name="d49a" id="d49a" class="graf graf--li graf-after--li">
                  Ask the coordinator to load a
                  <strong class="markup--strong markup--li-strong"
                    >persistent store</strong
                  >
                </li>
                <li name="f8c5" id="f8c5" class="graf graf--li graf-after--li">
                  Create one or more
                  <strong class="markup--strong markup--li-strong"
                    >managed object contexts</strong
                  >
                </li>
              </ul>
              <p name="5e18" id="5e18" class="graf graf--p graf-after--li">
                <strong class="markup--strong markup--p-strong"
                  >Starting with iOS 10 the </strong
                ><code class="markup--code markup--p-code"
                  ><strong class="markup--strong markup--p-strong"
                    >NSPersistentContainer</strong
                  ></code
                ><strong class="markup--strong markup--p-strong">
                  removes most of this boilerplate code. </strong
                >A container that encapsulates the Core Data stack in your
                application.
              </p>
              <p name="0f11" id="0f11" class="graf graf--p graf-after--p">
                If you adopt some simple naming conventions and the default
                store location the setup of a core data stack can be as simple
                as this:
              </p>
              <pre
                name="eb18"
                id="eb18"
                class="graf graf--pre graf-after--p"
              ><code class="markup--code markup--pre-code">container = NSPersistentContainer(name: &quot;storeName&quot;)<br>container.loadPersistentStores { (storeDescription, error) in<br>  if let error = error {<br>    fatalError(&quot;Failed to load store: \(error)&quot;)<br>  }<br>}</code></pre>
              <p name="55fb" id="55fb" class="graf graf--p graf-after--pre">
                you need to set the store description
                <strong class="markup--strong markup--p-strong">before</strong>
                you load the store.
              </p>
              <h4 name="776e" id="776e" class="graf graf--h4 graf-after--p">
                Persistent Store Descriptor
              </h4>
              <p name="ff23" id="ff23" class="graf graf--p graf-after--h4">
                A persistent container collects the settings for a persistent
                store into a
                <strong class="markup--strong markup--p-strong"
                  >persistent store descriptor</strong
                >. To override the defaults create a new descriptor before
                loading the store. You create a persistent store descriptor with
                the URL for the store.The most commonly used configuration
                settings:
              </p>
              <ul class="postList">
                <li name="a0b7" id="a0b7" class="graf graf--li graf-after--p">
                  <strong class="markup--strong markup--li-strong">type</strong
                  >:
                  <code class="markup--code markup--li-code">String</code>
                  constant specifying the store type (default is
                  <code class="markup--code markup--li-code"
                    >NSSQLLiteStoreType</code
                  >).
                </li>
                <li name="098e" id="098e" class="graf graf--li graf-after--li">
                  <strong class="markup--strong markup--li-strong"
                    >isReadOnly</strong
                  >: <code class="markup--code markup--li-code">Bool</code> set
                  to <code class="markup--code markup--li-code">true</code> for
                  a read only store (default is
                  <code class="markup--code markup--li-code">false</code>).
                </li>
                <li name="53f0" id="53f0" class="graf graf--li graf-after--li">
                  <strong class="markup--strong markup--li-strong"
                    >shouldAddStoreAsynchronously</strong
                  >: <code class="markup--code markup--li-code">Bool</code> set
                  to <code class="markup--code markup--li-code">true</code> to
                  add a store to the coordinator asynchronously on a background
                  thread. The default is
                  <code class="markup--code markup--li-code">false</code> which
                  adds the store synchronously on the calling thread.
                </li>
                <li name="1cc9" id="1cc9" class="graf graf--li graf-after--li">
                  <strong class="markup--strong markup--li-strong"
                    >shouldInferMappingAutomatically</strong
                  >: <code class="markup--code markup--li-code">Bool</code> if
                  the flag
                  <code class="markup--code markup--li-code"
                    >shouldMigrateStoreAutomatically</code
                  >
                  is <code class="markup--code markup--li-code">true</code> try
                  to infer a mapping model when migrating. Default is
                  <code class="markup--code markup--li-code">true</code>.
                </li>
                <li name="fdee" id="fdee" class="graf graf--li graf-after--li">
                  <strong class="markup--strong markup--li-strong"
                    >shouldMigrateStoreAutomatically</strong
                  >:
                  <code class="markup--code markup--li-code">Bool</code> migrate
                  the store automatically. Default is
                  <code class="markup--code markup--li-code">true</code>.
                </li>
              </ul>
              <p name="aaf1" id="aaf1" class="graf graf--p graf-after--li">
                So to create a read-only persistent store that loads
                asynchronously on a background thread (and by default that
                migrates automatically):
              </p>
              <pre
                name="1060"
                id="1060"
                class="graf graf--pre graf-after--p"
              ><code class="markup--code markup--pre-code">let url = NSPersistentContainer.defaultDirectoryURL()<br>let description = NSPersistentStoreDescription(url: url)<br>description.shouldAddStoreAsynchronously = true<br>description.isReadOnly = true<br>container.persistentStoreDescriptions = [description]</code></pre>
              <h4 name="9504" id="9504" class="graf graf--h4 graf-after--pre">
                Getting the Main View¬†Context
              </h4>
              <p name="0a1b" id="0a1b" class="graf graf--p graf-after--h4">
                The persistent container has a convenient read-only property
                named
                <code class="markup--code markup--p-code">viewContext</code> to
                get the
                <strong class="markup--strong markup--p-strong"
                  >managed object context</strong
                >
                for the
                <strong class="markup--strong markup--p-strong"
                  >main queue</strong
                >. As the name suggests this is the context you should be using
                when working with your user interface.
              </p>
              <pre
                name="271d"
                id="271d"
                class="graf graf--pre graf-after--p"
              ><code class="markup--code markup--pre-code">container.viewContext.perform({<br>  // ...<br>})</code></pre>
              <h4 name="f76e" id="f76e" class="graf graf--h4 graf-after--pre">
                Performing a Background Task
              </h4>
              <p name="6e67" id="6e67" class="graf graf--p graf-after--h4">
                To avoid blocking the user interface you should not use the main
                view context for time consuming tasks. Create a
                <strong class="markup--strong markup--p-strong"
                  >private managed object context</strong
                >
                and execute the task in the background. The persistent container
                has a convenience method that takes care of creating a temporary
                private context for you and takes a block to execute:
              </p>
              <pre
                name="ee01"
                id="ee01"
                class="graf graf--pre graf-after--p"
              ><code class="markup--code markup--pre-code">container.performBackgroundTask({ (context) in <br>  // ... do some task on the context</code></pre>
              <pre
                name="041c"
                id="041c"
                class="graf graf--pre graf-after--pre"
              ><code class="markup--code markup--pre-code">  // save the context<br>  do {<br>    try context.save()<br>  } catch {<br>    // handle error<br>  }<br>})</code></pre>
              <h4 name="9b7c" id="9b7c" class="graf graf--h4 graf-after--pre">
                Getting a Private¬†Context
              </h4>
              <p name="4967" id="4967" class="graf graf--p graf-after--h4">
                You can also just get a new private context to use anyway you
                see fit:
              </p>
              <pre
                name="59bc"
                id="59bc"
                class="graf graf--pre graf-after--p"
              ><code class="markup--code markup--pre-code">let context = persistentContainer.newBackgroundContext()<br>context.perform({<br>  // ...<br>})</code></pre>
              <h4 name="278b" id="278b" class="graf graf--h4 graf-after--pre">
                Core Data, Multithreading, and the Main¬†Thread
              </h4>
              <p name="6592" id="6592" class="graf graf--p graf-after--h4">
                Working with Core Data on multiple threads is actually very
                simple from a theoretical point of view.
                <code class="markup--code markup--p-code">NSManagedObject</code
                >,
                <code class="markup--code markup--p-code"
                  >NSManagedObjectContext</code
                >, and
                <code class="markup--code markup--p-code"
                  >NSPersistentStoreCoordinator</code
                >
                aren&#39;t thread safe.
              </p>
              <p name="cfed" id="cfed" class="graf graf--p graf-after--p">
                <strong class="markup--strong markup--p-strong"
                  >Thread confinement:</strong
                >
                Create a managed object context for every thread that interacts
                with Core Data.
                <code class="markup--code markup--p-code"
                  >NSManagedObjectContext</code
                >
                class isn&#39;t thread safe.
              </p>
              <figure
                name="bf07"
                id="bf07"
                class="graf graf--figure graf-after--p"
              >
                <img
                  class="graf-image"
                  data-image-id="1*oqDW9ODtheJ8dMTPN9HPUw.png"
                  data-width="745"
                  data-height="69"
                  src="https://cdn-images-1.medium.com/max/800/1*oqDW9ODtheJ8dMTPN9HPUw.png"
                />
              </figure>
              <p name="1404" id="1404" class="graf graf--p graf-after--figure">
                So far, we‚Äôve learned that you need multiple managed object
                contexts if you perform Core Data operations on multiple
                threads. The caveat, however, is that managed object contexts
                are unaware of each others existence. Changes made to a managed
                object in one managed object context are not automatically
                propagated to other managed object contexts. How do we solve
                this problem?
              </p>
              <p name="e640" id="e640" class="graf graf--p graf-after--p">
                There are two popular strategies that Apple recommends,
                notifications and parent-child managed object contexts.
              </p>
              <ol class="postList">
                <li name="a50e" id="a50e" class="graf graf--li graf-after--p">
                  <strong class="markup--strong markup--li-strong"
                    >Notifications</strong
                  >
                </li>
              </ol>
              <p name="8c7d" id="8c7d" class="graf graf--p graf-after--li">
                Managed object context posts three types of notifications:
              </p>
              <ul class="postList">
                <li name="1f6f" id="1f6f" class="graf graf--li graf-after--p">
                  <code class="markup--code markup--li-code"
                    >NSManagedObjectContextObjectsDidChangeNotification</code
                  >: This notification is posted when one of the managed objects
                  of the managed object context has changed.
                </li>
                <li name="8fb2" id="8fb2" class="graf graf--li graf-after--li">
                  <code class="markup--code markup--li-code"
                    >NSManagedObjectContextWillSaveNotification</code
                  >: This notification is posted
                  <strong class="markup--strong markup--li-strong"
                    >before</strong
                  >
                  the managed object context performs a save operation.
                </li>
                <li name="5480" id="5480" class="graf graf--li graf-after--li">
                  <code class="markup--code markup--li-code"
                    >NSManagedObjectContextDidSaveNotification</code
                  >: This notification is posted
                  <strong class="markup--strong markup--li-strong"
                    >after</strong
                  >
                  the managed object context performs a save operation.
                </li>
              </ul>
              <p name="dfe9" id="dfe9" class="graf graf--p graf-after--li">
                When a managed object context saves its changes to a persistent
                store, via the persistent store coordinator, other managed
                object contexts may want to know about those changes.
              </p>
              <p name="ad62" id="ad62" class="graf graf--p graf-after--p">
                2.
                <strong class="markup--strong markup--p-strong"
                  >Parent/Child Managed Object Contexts</strong
                >
              </p>
              <figure
                name="c292"
                id="c292"
                class="graf graf--figure graf-after--p"
              >
                <img
                  class="graf-image"
                  data-image-id="1*fVxyFLreAO7D1eaPxxeBRQ.png"
                  data-width="600"
                  data-height="450"
                  src="https://cdn-images-1.medium.com/max/800/1*fVxyFLreAO7D1eaPxxeBRQ.png"
                />
              </figure>
              <h4
                name="eebd"
                id="eebd"
                class="graf graf--h4 graf-after--figure"
              >
                Creating a child managed object context is only slightly
                different from what we‚Äôve seen so far. We initialize a child
                managed object context by invoking
                <code class="markup--code markup--h4-code"
                  >init(concurrencyType:)</code
                >. The concurrency type the initializer accepts defines the
                managed object context&#39;s threading model. Let&#39;s look at
                each concurrency type.
              </h4>
              <ul class="postList">
                <li name="24e1" id="24e1" class="graf graf--li graf-after--h4">
                  <code class="markup--code markup--li-code"
                    >MainQueueConcurrencyType</code
                  >: The managed object context is only accessible from the main
                  thread. An exception is thrown if you try to access it from
                  any other thread.
                </li>
                <li name="9f03" id="9f03" class="graf graf--li graf-after--li">
                  <code class="markup--code markup--li-code"
                    >PrivateQueueConcurrencyType</code
                  >: When creating a managed object context with a concurrency
                  type of
                  <code class="markup--code markup--li-code"
                    >PrivateQueueConcurrencyType</code
                  >, the managed object context is associated with a private
                  queue and it can only be accessed from that private queue.
                </li>
                <li name="265b" id="265b" class="graf graf--li graf-after--li">
                  <code class="markup--code markup--li-code"
                    >ConfinementConcurrencyType</code
                  >: This is the concurrency type that corresponds with the
                  <strong class="markup--strong markup--li-strong"
                    >thread confinement</strong
                  >
                  concept we explored earlier. If you create a managed object
                  context using
                  <code class="markup--code markup--li-code">init()</code>, the
                  concurrency type of that managed object context is
                  <code class="markup--code markup--li-code"
                    >ConfinementConcurrencyType</code
                  >.
                  <strong class="markup--strong markup--li-strong"
                    >Apple has deprecated this concurrency type as of iOS 9.
                    This also means that </strong
                  ><code class="markup--code markup--li-code"
                    ><strong class="markup--strong markup--li-strong"
                      >init()</strong
                    ></code
                  ><strong class="markup--strong markup--li-strong">
                    is deprecated as of iOS 9.</strong
                  >
                </li>
              </ul>
              <p name="4f44" id="4f44" class="graf graf--p graf-after--li">
                There are two key methods that were added to the Core Data
                framework when Apple introduced parent/child managed object
                contexts,
                <code class="markup--code markup--p-code"
                  >performBlock(_:)</code
                >
                and
                <code class="markup--code markup--p-code"
                  >performBlockAndWait(_:)</code
                >. Both methods will make your life much easier. When you call
                <code class="markup--code markup--p-code"
                  >performBlock(_:)</code
                >
                on a managed object context and pass in a block of code to
                execute, Core Data makes sure that the block is executed on the
                correct thread. In the case of the
                <code class="markup--code markup--p-code"
                  >PrivateQueueConcurrencyType</code
                >
                concurrency type, this means that the block is executed on the
                private queue of that managed object context.
              </p>
              <p name="23fb" id="23fb" class="graf graf--p graf-after--p">
                For more details‚Ää‚Äî
                <a
                  href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/Concurrency.html#//apple_ref/doc/uid/TP40001075-CH24-SW1"
                  data-href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/Concurrency.html#//apple_ref/doc/uid/TP40001075-CH24-SW1"
                  class="markup--anchor markup--p-anchor"
                  rel="nofollow noopener"
                  target="_blank"
                  >https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/Concurrency.html#//apple_ref/doc/uid/TP40001075-CH24-SW1</a
                >
              </p>
              <h3 name="17b6" id="17b6" class="graf graf--h3 graf-after--p">
                Bonus time: @IBDesignable and @IBInspectable
              </h3>
              <h3 name="6a9b" id="6a9b" class="graf graf--h3 graf-after--h3">
                IBDesignable
              </h3>
              <p name="9e97" id="9e97" class="graf graf--p graf-after--h3">
                <em class="markup--em markup--p-em"
                  >IBDesignable attribute will identify the UIView or the
                  elements inherited from UIView‚Ää‚Äî‚ÄäEg: UIButton, UIImageView,
                  UILabel etc..</em
                >
              </p>
              <p name="05bb" id="05bb" class="graf graf--p graf-after--p">
                For example¬†, I created a Custom UIButton class,
              </p>
              <pre
                name="1f35"
                id="1f35"
                class="graf graf--pre graf-after--p"
              >@IBDesignable<br>open class MYHighLightedButton: UIButton {</pre>
              <pre
                name="9323"
                id="9323"
                class="graf graf--pre graf-after--pre"
              >public override init(frame: CGRect) {<br>        super.init(frame: frame)<br>        setTitle(&quot;MyTitle&quot;, for: .normal)<br>        setTitleColor(UIColor.blue, for: .normal)<br>    }</pre>
              <pre
                name="2f75"
                id="2f75"
                class="graf graf--pre graf-after--pre"
              >public required init?(coder aDecoder: NSCoder) {<br>        super.init(coder: aDecoder)<br>    }</pre>
              <pre name="4b74" id="4b74" class="graf graf--pre graf-after--pre">
}</pre
              >
              <p name="d4d7" id="d4d7" class="graf graf--p graf-after--pre">
                You can add custom view in your xib¬†, In the Interface Builder
                (`StoryBoard`) drag and drop a UIButton. Go to the `<strong
                  class="markup--strong markup--p-strong"
                  ><em class="markup--em markup--p-em"
                    >Show the Identity Inspector</em
                  ></strong
                >` and set the Class and Module as
                <strong class="markup--strong markup--p-strong"
                  >MYHighLightedButton</strong
                >.
              </p>
              <h3 name="bd3a" id="bd3a" class="graf graf--h3 graf-after--p">
                IBInspectable
              </h3>
              <p name="2bd2" id="2bd2" class="graf graf--p graf-after--h3">
                Lets add some custom properties our button. üôå üôå
              </p>
              <p name="214a" id="214a" class="graf graf--p graf-after--p">
                For this we have to use
                <strong class="markup--strong markup--p-strong"
                  ><em class="markup--em markup--p-em"
                    >IBInspectable</em
                  ></strong
                >
                attribute. Let‚Äôs see how we can add them.
              </p>
              <pre
                name="7317"
                id="7317"
                class="graf graf--pre graf-after--p"
              >@IBInspectable<br>    public var cornerRadius: CGFloat = 2.0 {<br>        didSet {<br>              self.layer.cornerRadius = self.cornerRadius<br>        }<br>    }</pre>
              <p name="e810" id="e810" class="graf graf--p graf-after--pre">
                This will add the corner_radius property to your button. You
                will be able to see them in the
                <strong class="markup--strong markup--p-strong"
                  ><em class="markup--em markup--p-em"
                    >Attributes Inspector¬†.</em
                  ></strong
                >
              </p>
              <figure
                name="904a"
                id="904a"
                class="graf graf--figure graf-after--p"
              >
                <img
                  class="graf-image"
                  data-image-id="1*T0LowH7AMrqbtRoQVYcWLQ.png"
                  data-width="1272"
                  data-height="118"
                  src="https://cdn-images-1.medium.com/max/800/1*T0LowH7AMrqbtRoQVYcWLQ.png"
                />
              </figure>
              <h3
                name="62bd"
                id="62bd"
                class="graf graf--h3 graf-after--figure"
              >
                <strong class="markup--strong markup--h3-strong"
                  >How to read only a few attributes of an¬†entity?</strong
                >
              </h3>
              <p name="ff3f" id="ff3f" class="graf graf--p graf-after--h3">
                We can use NSFetchRequest class‚Äôs property
                ‚ÄúsetPropertiesToFetch‚Äù. We can pass a array of properties in
                string format in setPropertiesToFetch method.
              </p>
              <h3 name="852f" id="852f" class="graf graf--h3 graf-after--p">
                Core Data vs¬†Sqlite?
              </h3>
              <p name="3a2f" id="3a2f" class="graf graf--p graf-after--h3">
                <strong class="markup--strong markup--p-strong"
                  >Core Data</strong
                >
                Works on object graph management. Operates on objects stored in
                memory. Can create millions of new objects in-memory very
                quickly.
              </p>
              <p name="c0c1" id="c0c1" class="graf graf--p graf-after--p">
                <strong class="markup--strong markup--p-strong">Sqlite </strong
                >Works on table structure with sql queries. Operates on data
                stored on disk. Can be slow to create millions of new rows, as
                it is a disk I/O operation &amp; Have keys like primary,
                composite keys.
              </p>
              <p name="06b0" id="06b0" class="graf graf--p graf-after--p">
                <strong class="markup--strong markup--p-strong"
                  >Knowledge is power!</strong
                >
              </p>
              <!-- <p
                name="b343"
                id="b343"
                class="graf graf--p graf-after--p graf--trailing"
              >
                Hope you are learning from it.<br /><strong
                  class="markup--strong markup--p-strong"
                  >Next Chapter</strong
                >
                :
                <a
                  href="https://medium.com/@nishantnitb/ios-2018-series-cracking-ios-interview-or-become-ios-expert-8-fd5f2cfd23ec"
                  data-href="https://medium.com/@nishantnitb/ios-2018-series-cracking-ios-interview-or-become-ios-expert-8-fd5f2cfd23ec"
                  class="markup--anchor markup--p-anchor"
                  target="_blank"
                  >Generics, LRU cache in swift</a
                >
              </p> -->
            </div>
          </div>
        </section>
      </section>
      <!-- <footer>
        <p>
          By
          <a href="https://medium.com/@nishantnitb" class="p-author h-card"
            >Nishant Sharma</a
          >
          on
          <a href="https://medium.com/p/cd272ab610d4"
            ><time class="dt-published" datetime="2018-06-03T08:35:26.006Z"
              >June 3, 2018</time
            ></a
          >.
        </p>
        <p>
          <a
            href="https://medium.com/@nishantnitb/ios-2018-series-cracking-ios-interview-or-become-ios-expert-7-cd272ab610d4"
            class="p-canonical"
            >Canonical link</a
          >
        </p>
        <p>
          Exported from <a href="https://medium.com">Medium</a> on February 11,
          2021.
        </p>
      </footer> -->
    </article>
  </body>
</html>
